from typing import Dict, List, Union

import attrs

from abegidd.entities import Explanation, JsonChain, Prediction, Rule
from abegidd.expanders import (
    group_chains_by_prediction,
    group_chains_with_the_same_nodes,
)


def filter_explanations(
    explanations: List[Explanation], filter_condition: Dict[int, List[str]]
) -> List[Explanation]:
    """
    remove redundant explanations

    :param explanations:  explanations generated by anyburl
    :param filter_condition: filter rules
    :return: filtered explanations
    """
    filtered_explanations = []
    for explanation in explanations:
        if len(explanation.rule_tails) > 0:
            tails = explanation.rule_tails
            filtered_rule_tails = _filter_rules(tails, filter_condition)
            explanation = attrs.evolve(explanation, rule_tails=filtered_rule_tails)
        if len(explanation.rule_heads) > 0:
            heads = explanation.rule_heads
            filtered_rule_heads = _filter_rules(heads, filter_condition)
            explanation = attrs.evolve(explanation, rule_heads=filtered_rule_heads)
        filtered_explanations.append(explanation)
    return filtered_explanations


def _filter_rules(
    explanations_rules: List[Rule], filter_condition: Dict[int, List[str]]
) -> List[Rule]:
    """
    remove redundant rules

    :param explanations_rules: AnyBURL rule class.
    :param filter_condition: filter conditions
    :return: Filtered rules
    """
    rules = []

    for rule in explanations_rules:
        edge_name_lst = [edge.edge_type for edge in rule.body_atoms]

        for limit, edges in filter_condition.items():
            if any(edge_name_lst.count(edge) > int(limit) for edge in edges):
                break
        else:
            rules.append(rule)
    return rules


def filter_predictions_for_node_names(
    predictions: List[Prediction],
    node_names: List[str],
) -> List[Prediction]:
    """
    Filter the prediction results based on provided filter list

    :param predictions: predictions collection
    :param node_names: list of node pref_names to filter with
    """

    filtered_predictions = []

    for prediction in predictions:
        sliced_heads = []
        for prediction_head in prediction.predicted_heads:
            if prediction_head.entity in node_names:
                sliced_heads.append(prediction_head)

        if len(sliced_heads) > 0:
            filtered_predictions.append(
                attrs.evolve(prediction, predicted_heads=sliced_heads)
            )

    return filtered_predictions


def filter_low_priority_duplicate_chains(
    chains: List[JsonChain], prioritised_edge_names: List[str]
) -> List[JsonChain]:
    out_chains: List[JsonChain] = []
    for prediction, prediction_group in group_chains_by_prediction(chains):
        for node_group in group_chains_with_the_same_nodes(prediction_group):
            # list of metapaths for each chain, eg
            # (
            #   {'label': 'COMPOUND_in_trial_for_DISEASE', 'reversed': False},
            #   {'label': 'COMPOUND_treats_DISEASE', 'reversed': False}
            # )
            metapath_label_iterator = zip(*[chain["metapath"] for chain in node_group])

            # we will set this to the node_group index of chain containing the preferred
            # edge name. If we don't encounter an edge with a prioritised preference we
            # return all the nodes in the node group
            preferred_index: Union[int, None] = None

            # for each row of ^^ find the index of the preferred edge
            for label_tuple in metapath_label_iterator:
                # if this row has preferred edges, choose that edges index
                if any(edge["label"] in prioritised_edge_names for edge in label_tuple):
                    for prioritised_edge_name in prioritised_edge_names:
                        labels: List[str] = [edge["label"] for edge in label_tuple]
                        # try to get the index of the preferred edge
                        try:
                            preferred_index = labels.index(prioritised_edge_name)
                            break
                        except ValueError:
                            continue
                    else:
                        raise ValueError("Could not find preferred chain")

            if preferred_index is not None:
                out_chains.append(node_group[preferred_index])
            else:
                out_chains.extend(node_group)

    return out_chains
